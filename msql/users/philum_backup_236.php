<?php
//philum_microsql_philum_backup_236
$r["_menus_"]=array('val0');
$r[1]=array('[philum_236_motormeta.jpg]

Système d\'édition en ligne

[--][[http://philum.org:w]:b] : Serveur de Blogs gratuit. 

[327:read]

[:last-update]');
$r[2]=array('[Système de gestion de contenu:b]

[philum_236_motorsystem.jpg]

[--]Serveur ouvert au public : [[http://philum.org:w]:b]

Wiki Framasoft : [http://wiki.framasoft.info/PropositionNotice/Philum]

[327:read]

[:last-update]');
$r[3]=array('[Constructeur de sites et plateforme de développement:b]

[[value§option:connector:on]:code]

La syntaxe des des connecteurs permet des fonctionnalités allant de la mise en forme html à l\'appel d\'APIs, et surtout d\'en écrire.

[philum_236_console.jpg§140/100:thumb]La page est construite par blocs interchangeables de modules paramétrables et conditionnés !

[philum_236_msql.jpg§140/100:thumb]Un système de base de données extensible permet à l\'utilisateur de traiter des données organisées

[philum_236_design.jpg§140/100:thumb][philum_236_design2.jpg§140/100:thumb]Le constructeur de design est un outil unique qui permet de créer une mise en page en quelques minutes

[philum_236_codeline.jpg§140/100:thumb]De nombreuses fonctions publiques du noyau sont rendues disponibles à l\'utilisateur pour construire des modules ou des connecteurs

[philum_236_update.jpg§140/100:thumb]Le logiciel reçoit régulièrement des mises à jour

[--]Serveur ouvert au public : [[http://philum.org:w]:b]

Wiki Framasoft : [http://wiki.framasoft.info/PropositionNotice/Philum]

[[327:read]:no]

[:last-update]');
$r[4]=array('[Constructeur de sites et plateforme de développement:b]

{{Inventeur du système des connecteurs, du constructeur de design, des microtables, et maintenant du [340§AMT] (Ajax Multithread)}}

[[value§option:connector:on]:code]

Les connecteurs sont la base du logiciel, ils permettent la mise en forme html comme l\'écriture de templates et l\'appel d\'APIs, et enfin d\'en écrire grâce au fait qu\'ils puissent être imbriqués.

[philum_236_console.jpg§140/100:thumb] Blocs de modules

[philum_236_design.jpg§140/100:thumb] Constructeur de design 

[philum_236_fontface.jpg§140/100:thumb] Font-Face

[philum_236_msql.jpg§140/100:thumb] Base de données utilisateur

[philum_236_codeline.jpg§140/100:thumb] Programmatique 

[philum_236_update.jpg§140/100:thumb] Mises à jour

[philum_236_batch.jpg§140/100:thumb] Importation en masse d\'articles

Le noyau du logiciel est une librairie vaste et puissante de fonctions php et javascript. La philosophie du développement a consisté à produire des utilitaires qui ont chacun leur fonctionnement propre et qui sont destinés à s\'emboîter les uns aux autres au moyen de protocoles. Le logiciel est l\'analogie d\'un ordinateur, avec sa carte-mère, son disque dur, sa carte graphique, sa mémoire vive et cache, les bus et les processeurs. Le noyau est le processeur, et les plugin y font référence, ils sont listés dans une table volatile, et utilisent les procédures mises en oeuvre dans le CMS.

Le développement d\'applications méritait de profiter des mêmes dispositions que la création d\'un site avec un CMS, c\'est à dire utiliser des routines classiques. Elles sont conçues pour être faciles à comprendre et logiques. Parce qu\'elles sont imbriquées, les routines existent à de nombreux niveaux de complexité, allant des fonctions PHP qui auraient dû exister aux objets classiques qui ne peuvent pas être écrits autrement.

[--]Serveur ouvert au public : [[http://philum.org:w]:b]

Wiki Framasoft : [http://wiki.framasoft.info/PropositionNotice/Philum]

[[327:read]:no]

[:last-update]');
$r[5]=array('[CMS
Edition de Sites
Organisation de contenu
Automate de reprise d\'articles
Plateforme de développement
Partage de fichiers server-to-server
Web-Os:b]

{{Nouveau ! le [347§Desktop]&nbsp;: 
- bureau avec des fichiers et des répertoires en pages d\'accueil
- permet de jongler avec plusieurs pages et outils simultanément
- accède aux modules, plugins, articles, tables, et au Finder}}

{{Nouveau ! le [348§Finder]&nbsp;: 
- partager des fichiers
- leur attribuer une url virtuelle,
- downloader de serveur à serveur à 80Mo/s !}}

[--][[value§option:connector:on]:code]

Cette syntaxe est celle des connecteurs et c\'est la base du logiciel, ils permettent la mise en forme Html comme l\'écriture de templates et l\'appel d\'applets, et surtout d\'en écrire des nouveaux grâce au fait qu\'ils puissent être imbriqués.

[philum_236_console.jpg§140/100:thumb] Blocs de modules

[philum_236_design.jpg§140/100:thumb] Constructeur de design 

[philum_236_fontface.jpg§140/100:thumb] Font-Face

[philum_236_msql.jpg§140/100:thumb] Base de données utilisateur

[philum_236_codeline.jpg§140/100:thumb] Programmatique 

[philum_236_update.jpg§140/100:thumb] Mises à jour

[philum_236_batch.jpg§140/100:thumb] Importation en masse d\'articles

[philum_236_finder.jpg§140/100:thumb] Finder : gestion et partage de fichiers

[philum_236_desktop.jpg§140/100:thumb] Desktop : un environnement pour la confection

Le noyau du logiciel est une librairie vaste et puissante de fonctions php et javascript. La philosophie du développement a consisté à produire des utilitaires qui ont chacun leur fonctionnement propre et qui sont destinés à s\'emboîter les uns aux autres au moyen de protocoles. Le logiciel est l\'analogie d\'un ordinateur, avec sa carte-mère, son disque dur, sa carte graphique, sa mémoire vive et cache, les bus et les processeurs. Le noyau est le processeur, et les plugin y font référence, ils sont listés dans une table volatile, et utilisent les procédures mises en oeuvre dans le CMS.

Le développement d\'applications méritait de profiter des mêmes dispositions que la création d\'un site avec un CMS, c\'est à dire utiliser des routines classiques. Elles sont conçues pour être faciles à comprendre et logiques. Parce qu\'elles sont imbriquées, les routines existent à de nombreux niveaux de complexité, allant des fonctions PHP qui auraient dû exister aux objets classiques qui ne peuvent pas être écrits autrement.

[--]Serveur ouvert au public : [http://philum.org:w]
Visitez [http://w41k.info:w]
Wiki Framasoft : [http://wiki.framasoft.info/PropositionNotice/Philum]

[[327:read]:no]

[:last-update]');
$r[6]=array('[CMS
Edition de Sites
Organisation de contenu
Automate de reprise d\'articles
Plateforme de développement
Partage de fichiers server-to-server
Web-Os:b]

{{Nouveau ! le [347§Desktop]&nbsp;: 
- bureau avec des fichiers et des répertoires en pages d\'accueil
- permet de jongler avec plusieurs pages et outils simultanément
- accède aux modules, plugins, articles, tables, et au Finder}}

{{Nouveau ! le [348§Finder]&nbsp;: 
- partager des fichiers
- leur attribuer une url virtuelle,
- downloader de serveur à serveur à 80Mo/s !}}

[--][[value§option:connector:on]:code]

Cette syntaxe est celle des connecteurs et c\'est la base du logiciel, ils permettent la mise en forme Html comme l\'écriture de templates et l\'appel d\'applets, et surtout d\'en écrire des nouveaux grâce au fait qu\'ils puissent être imbriqués.

[philum_236_console.jpg§140/100:thumb] Blocs de modules

[philum_236_design.jpg§140/100:thumb] Constructeur de design 

[philum_236_fontface.jpg§140/100:thumb] Font-Face

[philum_236_msql.jpg§140/100:thumb] Base de données utilisateur

[philum_236_codeline.jpg§140/100:thumb] Programmatique 

[philum_236_update.jpg§140/100:thumb] Mises à jour

[philum_236_batch.jpg§140/100:thumb] Importation en masse d\'articles

[philum_236_finder.jpg§140/100:thumb] Finder : gestion et partage de fichiers

[philum_236_desktop.jpg§140/100:thumb] Desktop : un environnement pour la confection

Le noyau du logiciel est une librairie vaste et puissante de fonctions php et javascript. La philosophie du développement a consisté à produire des utilitaires qui ont chacun leur fonctionnement propre et qui sont destinés à s\'emboîter les uns aux autres au moyen de protocoles. Le logiciel est l\'analogie d\'un ordinateur, avec sa carte-mère, son disque dur, sa carte graphique, sa mémoire vive et cache, les bus et les processeurs. Le noyau est le processeur, et les plugin y font référence, ils sont listés dans une table volatile, et utilisent les procédures mises en oeuvre dans le CMS.

Le développement d\'applications méritait de profiter des mêmes dispositions que la création d\'un site avec un CMS, c\'est à dire utiliser des routines classiques. Elles sont conçues pour être faciles à comprendre et logiques. Parce qu\'elles sont imbriquées, les routines existent à de nombreux niveaux de complexité, allant des fonctions PHP qui auraient dû exister aux objets classiques qui ne peuvent pas être écrits autrement.

[--]Serveur ouvert au public : [http://philum.org:w]
Visitez [http://w41k.info:w]
Wiki Framasoft : [http://wiki.framasoft.info/PropositionNotice/Philum]

[[327:read]:no]

[:last-update]');
$r[7]=array('[logo§22:picto]

[CMS:h]

Système de publication
Automate de reprise d\'articles
Plateforme de développement
Partage de fichiers
Web-Os

[La Philosophie:h]

Tout ce qui est produit l\'est dans l\'esprit de la gratuité et de l\'entraide.
Faire un site repose sur des routines classiques quoi qu\'incroyablement nombreuses, dont la combinaison fait la complexité. Le CMS est le point de départ de la créativité. Il est conçu pour permettre des utilisations qui n\'ont pas été spécifiquement pensées lors de sa conception.

[La programmation:h]

L\'idée globale d\'un CMS c\'est que les fonctions d\'un site, son interaction, sa structure, sont conçus de façon générique. Ainsi il n\'y a pas une mais plusieurs manières d\'obtenir un résultat, car les composants sont pensés pour s\'assembler.
Dans la pratique cela a fait apparaître la notion de densité du système. Le but étant que le temps d\'exécution soit fulgurant, le rapport poids / nombre de fonctionnalités est dû au fait que l\'écriture du code constitue en soi un langage.
Suite à quoi il ne restait qu\'à interfacer cela avec un langage utilisateur qui lui paraisse simple et logique.

[Le principe de base:h]

[[value§option:connector:on]:code]

Le système des connecteurs assure l\'homogénéité de la mise en forme quelle que soit la source des données et un gain de poids de 30% dans les bases de données.
Ils permettent même l\'écriture de templates ou encore d\'APIs dont le contenu de la balise est une variable.

[[hello:b:on]
[hello§param:my_plugin:on]:code]

[\'hello\' traité par le connecteur \'bold\', ou par une API créée par l\'utilisateur, que ce soit avec des ressources locales (langage \'codeline\') ou dans un plugin écrit en PHP):l]

[Utilisation:h]

[philum_236_console.jpg§Blocs de modules]
[philum_236_design.jpg§Constructeur de design]
[philum_236_fontface.jpg§Font-Face]
[philum_236_msql.jpg§Base de données utilisateur]
[philum_236_codeline.jpg§Programmatique]
[philum_236_update.jpg§Mises à jour]
[philum_236_batch.jpg§Importation en masse d\'articles]
[philum_236_finder.jpg§Finder (gestion et partage de fichiers)]
[philum_236_desktop.jpg§Desktop (un environnement pour la confection)]

[Plateforme de Dev:h]

Le noyau du logiciel est une librairie qui permet de couvrir une vaste section d\'usages. Le développement d\'applications profite des dispositions du CMS. Il suffit de placer un plugin pour qu\'il soit joignable par le connecteur portant son nom. Le fichier \'[model.php:code]\' explique les protocoles.
A un niveau de moindre complexité on peut assembler des fonctions au sein d\'un connecteur utilisateur, qui peut ensuite être rendu public.

[Evolution:h]

Philum a imposé (et ainsi nommé) l\'usage des \'popups\' comme un composant essentiel du logiciel. Tout le travail accompli vise à rendre l\'exécution plus facile, plus fiable, et plus rapide. Au final le CMS devient plutôt un OS.

[--]Serveur ouvert au public : [http://philum.org:w]
Visitez [http://w41k.info:w]
Wiki Framasoft : [http://wiki.framasoft.info/PropositionNotice/Philum]

[[327:read]:no]

[:last-update]');
$r[8]=array('[logo§22:picto]

[philum_236_pub.jpg][Un bureau hyperactif !:q]

[CMS:h]

Système de publication
Automate de reprise d\'articles
Plateforme de développement
Partage de fichiers
Web-Os

[La Philosophie:h]

Tout ce qui est produit l\'est dans l\'esprit de la gratuité et de l\'entraide.
Faire un site repose sur des routines classiques quoi qu\'incroyablement nombreuses, dont la combinaison fait la complexité. Le CMS est le point de départ de la créativité. Il est conçu pour permettre des utilisations qui n\'ont pas été spécifiquement pensées lors de sa conception.

[La programmation:h]

L\'idée globale d\'un CMS c\'est que les fonctions d\'un site, son interaction, sa structure, sont conçus de façon générique. Ainsi il n\'y a pas une mais plusieurs manières d\'obtenir un résultat, car les composants sont pensés pour s\'assembler.
Dans la pratique cela a fait apparaître la notion de densité du système. Le but étant que le temps d\'exécution soit fulgurant, le rapport poids / nombre de fonctionnalités est dû au fait que l\'écriture du code constitue en soi un langage.
Suite à quoi il ne restait qu\'à interfacer cela avec un langage utilisateur qui lui paraisse simple et logique.

[Le principe de base:h]

[[value§option:connector:on]:code]

Le système des connecteurs assure l\'homogénéité de la mise en forme quelle que soit la source des données et un gain de poids de 30% dans les bases de données.
Ils permettent même l\'écriture de templates ou encore d\'APIs dont le contenu de la balise est une variable.

[[hello:b:on]
[hello§param:my_plugin:on]:code]

[\'hello\' traité par le connecteur \'bold\', ou par une API créée par l\'utilisateur, que ce soit avec des ressources locales (langage \'codeline\') ou dans un plugin écrit en PHP):l]

[Utilisation:h]

[philum/guide13/pres1/presentation01.jpg§Blocs de modules]
[philum/guide13/pres1/presentation02.jpg§Constructeur de design]
[philum/guide13/pres1/presentation03.jpg§Font-Face]
[philum/guide13/pres1/presentation05.jpg§Base de données utilisateur]
[philum/guide13/pres1/presentation06.jpg§Programmatique]
[philum/guide13/pres1/presentation07.jpg§Templates]
[philum/guide13/pres1/presentation08.jpg§Mises à jour]
[philum/guide13/pres2/presentation46.jpg§Importation en masse d\'articles]
[philum/guide13/pres1/presentation17.jpg§le Finder (gestion et partage de fichiers)]
[philum/guide13/pres1/presentation33.jpg§le Desktop (un environnement pour la confection)]

Visitez [358§le Tour], ou [129§le Tour en Slideshow]

[Plateforme de Dev:h]

Le noyau du logiciel est une librairie qui permet de couvrir une vaste section d\'usages. Le développement d\'applications profite des dispositions du CMS. Il suffit de placer un plugin pour qu\'il soit joignable par le connecteur portant son nom. Le fichier \'[model.php:code]\' explique les protocoles.
A un niveau de moindre complexité on peut assembler des fonctions au sein d\'un connecteur utilisateur, qui peut ensuite être rendu public.

[Evolution:h]

Philum a imposé (et ainsi nommé) l\'usage des \'popups\' comme un composant essentiel du logiciel. Tout le travail accompli vise à rendre l\'exécution plus facile, plus fiable, et plus rapide. Au final le CMS devient plutôt un OS.

[--]Serveur ouvert au public : [http://philum.org]
Wiki Framasoft : [http://wiki.framasoft.info/PropositionNotice/Philum]
Twitter: [https://twitter.com/philumcms] [@philumcms]
Visitez [http://w41k.info]

[[327:read]:no]

[:last-update]');
$r[9]=array('[[pHiluM§32:size]§microsys:font]

[philum_236_pub.jpg]

[CMS:h]

Système de publication
Automate de reprise d\'articles
Plateforme de développement
Partage de fichiers
Web-Os

[Caractéristiques:h]

Publication et édition sur place
Desktop avec Apps
Ajax MultiThreads
SGBD de type «&nbsp;NoSql&nbsp;»
Gestion des membres
Constructeur de Css
multi-Hubs et multi-sites
Normalisation du HTML
Aspiration d\'articles en masse
Vitesse d\'exécution du code maximisée
Système de connecteurs (applicatifs au sein des articles)
Développement Offline (Ajout de fonctionnalités sans toucher au noyau)
Plugins et programmatique (langage de programmation orienté utilisateur)
Client-serveur : mise à jour automatique, partage de fichiers et d\'articles
Chat entre serveurs de type \"Twitter\" (Rss)

[La Philosophie:h]

Tout ce qui est produit l\'est dans l\'esprit de la gratuité et de l\'entraide.
Faire un site repose sur des routines classiques quoi qu\'incroyablement nombreuses, dont la combinaison fait la complexité. Le CMS est le point de départ de la créativité. Il est conçu pour permettre des utilisations qui n\'ont pas été spécifiquement pensées lors de sa conception.

[La programmation:h]

L\'idée globale d\'un CMS c\'est que les fonctions d\'un site, son interaction, sa structure, sont conçus de façon générique. Ainsi il n\'y a pas une mais plusieurs manières d\'obtenir un résultat, car les composants sont pensés pour s\'assembler.
Dans la pratique cela a fait apparaître la notion de densité du système. Le but étant que le temps d\'exécution soit fulgurant, le rapport poids / nombre de fonctionnalités est dû au fait que l\'écriture du code constitue en soi un langage.
Suite à quoi il ne restait qu\'à interfacer cela avec un langage utilisateur qui lui paraisse simple et logique.

[Le principe de base:h]

[[value§option:connector:on]:code]

Le système des connecteurs assure l\'homogénéité de la mise en forme quelle que soit la source des données et un gain de poids de 30% dans les bases de données.
Ils permettent même l\'écriture de templates ou encore d\'APIs dont le contenu de la balise est une variable.

[[hello:b:on]
[hello§param:my_plugin:on]:code]

[\'hello\' traité par le connecteur \'bold\', ou par une API créée par l\'utilisateur, que ce soit avec des ressources locales (langage \'codeline\') ou dans un plugin écrit en PHP):l]

[Utilisation:h]

[philum/guide13/pres1/presentation01.jpg§Blocs de modules]
[philum/guide13/pres1/presentation02.jpg§Constructeur de design]
[philum/guide13/pres1/presentation03.jpg§Font-Face]
[philum/guide13/pres1/presentation05.jpg§Base de données utilisateur]
[philum/guide13/pres1/presentation06.jpg§Programmatique]
[philum/guide13/pres1/presentation07.jpg§Templates]
[philum/guide13/pres1/presentation08.jpg§Mises à jour]
[philum/guide13/pres2/presentation46.jpg§Importation en masse d\'articles]
[philum/guide13/pres1/presentation17.jpg§le Finder (gestion et partage de fichiers)]
[philum/guide13/pres1/presentation33.jpg§le Desktop (un environnement pour la confection)]

Visitez [358§le Tour], ou [129§le Tour en Slideshow]

[Plateforme de Dev:h]

Le noyau du logiciel est une librairie qui permet de couvrir une vaste section d\'usages. Le développement d\'applications profite du Framework. Les plugins sont joignables par le connecteur portant son nom. Le fichier \'[model.php:code]\' explique les protocoles. Une classe objet \'Msql\' permet la gestion de microbases.
A un niveau de moindre complexité on peut assembler des fonctions au sein d\'un connecteur utilisateur, qui peut ensuite être rendu public et partagé.

[Evolution:h]

Philum a imposé (et ainsi nommé) l\'usage des \'popups\' comme un composant essentiel du logiciel. Tout le travail accompli vise à rendre l\'exécution plus facile, plus fiable, et plus rapide. Au final le CMS devient plutôt un OS.

[--]Serveur ouvert au public : [http://philum.org]
Wiki Framasoft : [http://wiki.framasoft.info/PropositionNotice/Philum]
Twitter: [http://twitter.com/philumcms] [@philumcms]
Visitez : [http://w41k.info§w41k], [http://philum.nous-les-dieux.org§nous-les-dieux]

[[327:read]:no]

[:last-update]');
$r[10]=array('[Framework de publication:b]

[Principales caractéristiques:h]

[Publication et édition sur place
Aspiration d\'article
Multisites
SGBD additionnelle de type « NoSql »
Gestion de membres
Normalisation html : Connecteurs
Vitesse d\'exécution maximisée
Développement Offline (sans toucher au noyau)
Partage de fichiers, d\'articles et Chat entre serveurs
Mises à jour automatiques:list]

Philum est un outil complexe et poussé.
Pour concevoir un site créatif, il faut une plateforme ouverte et dont toutes les routines sont déclinables et améliorables. Pour cela, il faut à son tour que le code suive des règles faciles à comprendre et applicables instinctivement ensuite.

[Usage minimal:h]

[Dans son état initial le logiciel permet de publier des articles en ligne, les organiser et les présenter.
A un premier niveau de curiosité on peut modifier son design et créer des variantes d\'une page à l\'autre.
Un utilisateur quotidien trouvera des automatismes appropriés à ses nouveaux besoins.
Un utilisateur expert peut développer ses propres fonctionnalités.
Un développeur découvrira un framework très poussé et maléable.:list]

[Connecteurs:h]

Ce langage utilisateur sert à écrire le html autant que des modules, en ne les désignant que par leur nom de balise. 
Il est relativement simple à lire :

[[[value§option:connector:on]:code]:list]

Le système des connecteurs assure l\'homogénéité de la mise en forme quelle que soit la source des données et un gain de poids de 30%.
Il permet aussi l\'écriture de templates ou encore de petites applis désignées par leur balise.

[[[hello:b:on]:code]:list]
[\'hello\' traité par le connecteur \'bold\':l]

[[[hello§param:my_plugin:on]:code]:list]

[Appel d\'un connecteur nommé \'my_plugin\' (soit créé en PHP, soit créé avec les dispositifs internes), auquel on envoie $p=hello et $o=param optionnel:l]

Visitez le [129§Tour]

[Dev:h]

Le Framework permet de couvrir une vaste section d\'usages. Un plugin comme le Chat entre Hubs s\'écrit en 40 lignes. Les plugins sont joignables par le connecteur portant son nom. Une classe objet \'Msql\' permet la gestion de bases de données utilisateur.
Les connecteurs peuvent ensuite être partagés.

--
[http://wiki.framasoft.info/PropositionNotice/Philum]
[http://twitter.com/philumcms§twitter] [@philumcms]
[http://w41k.com]

[:last-update]');
$r[11]=array('[Présentation du projet:h]

L\'idée est que si on fait un travail il faut qu\'il serve le plus longtemps possible. L\'informatique permet d\'ajouter l\'intelligence des uns et des autres, au fil des années.
C\'est donc naturel que les logiciels soient rédigés non pas seulement pour fonctionner mais aussi pour être lus, compris, entretenus et développés. Et ces cités restent belles tant que leurs idées restent belles !

[Présentation du framework:h]

Le développement d\'un site à haute fréquentation et avec une publication constante a conduit à construire des outils de traitement des données aussi variés que complexes.

Le logiciel et tous ses composants sont écris selon la forme :

[définition => processus => assemblage:q]

L\'avantage de l\'orienté composant est de pouvoir assembler n\'importe quel processus utilisant n\'importe quelle source de données.

Ainsi les fonctions sont classées entre celles du noyau (très simples et n\'en appelant aucune autre), les processus (qui utilisent des fonctions publiques et des privées), et les dispositifs d\'assemblage des données.

Au chapitre de l\'assemblage il faut surtout noter le fait que les processus soient tous conforme à des [protocoles:b] connus par les assembleurs. Pour cela on a nommé différents types de tableaux multidimensionnels (aux doux noms de v, k, kv, kkv etc...)

Ainsi les templates sont traités par des fonctions satellites de celles qui ont généré les variables qui vont y être injectées [[c\'était obligé sinon ça tournait en boucle]:l].
En fait, plus simplement, on a un énorme dispositif nommé \"les connecteurs\" qui remplace le html. Le contenu des données est contrôlé balise par balise (et le superflu est supprimé), de façon à produire des pages 30% plus légères qu\'en html.
Surtout ces connecteurs font bien plus que ce que font de simples balises. 

Finalement l\'idée géniale du logiciel était de faire que les balises soient autant de fonctions qu\'on pouvait appeler, de façon à les assembler pour générer des [micro-applications:b].

Ce qui est difficile dans ce projet est de trouver la bonne échelle de ces fonctions et applications, car au final ça commence très bas, et ce qui apparaît à l\'utilisateur est déjà de l\'ordre de la troisième couche système du logiciel (puisque les assemblages de fonctions constitue autant de composants pour d\'autres assemblages).

C\'est pour cette raison que le framework est \"orienté composant\", ce qui parfois fait grimacer... En fait si on veut les assembler à la chaîne (de façon fractale), cela suppose une très grande rigidité dans la façon dont elles sont organisées, régies et rédigées.

L\'outil mit à disposition pour créer des fonctions (utilisées comme modules) en est à une phase extrêmement primitive de son évolution, et ça s\'appelle le \"codeline basic\" (parce que ça écrit du code en une ligne). C\'est une fonction satellite du \"codeline\" servant à rédiger les templates, qui est elle-même une fonction très allégée des Connecteurs.
Bon pour l\'instant ça sert juste pour des petits automatismes,comme par exemple ceux qui donnent des stats sur le logiciel, en page de download).

Sinon à part ça il reste à utiliser un parmi une [centaine de modules:b] et ses nombreux paramètres globaux, locaux et ponctuels.

En résumé on a&nbsp;:
[des modules qui utilisent des paramètres complexes (ce sont des traitement, qui réclament des données et des modes d\'assemblage)
des connecteurs, nombreux, peu paramétrables, possible à rédiger en clbasic
des templates, dans lesquels on place les variables, rédigés en codeline (qui sont des connecteurs orientés html)
des plugins, qui ont des tâches spécialisées, qui doivent être rédigées en php, en utilisant (ou pas) les ressources du framework.:list]

[Les connecteurs:h4]

Les connecteurs sont des commandes pour des activités, qui peuvent être complexes. C\'est finalement l\'accès complet à un logiciel (logé dans un plugin). Ils sont parfois plus complexes que les modules, peuvent servir de modules ou utiliser leurs ressources.

En fait les [plugins:b] peuvent être appelés en tant que module (hors de l\'article) ou connecteur (dans l\'article).

Voici quelques exemples de connecteurs disponibles par défaut&nbsp;:
[des liens opérationnels (youtube renvoie une popup, pdf un player... et une image&nbsp;: pas besoin de la rédiger
des galeries d\'images (:photo, :slider, :sliderj),
une&nbsp;:radio, 
une&nbsp;:petition, 
un livre d\'articles (:book), 
un autre article local, sur place ou en popup (:popart)
un article d\'un autre serveur philum (:rss_art)
un lecteur de bases de données utilisateurs d\'après un template (:msql_template), 
un menu ouvrable (:apps),
un template (:codeline)
une ressource système (:basic)
etc etc...:list]

[Les plugins:h4]

L\'écosystème des plugins a été particulièrement soigné, parce que les plugins on peut en avoir besoin à de très nombreuses étapes (ou échelles) du logiciel.

Ce qui les caractérise est qu\'ils ne sont pas vitaux pour le logiciel, même s\'ils peuvent être requis par des options qui ne sont pas celles par défaut (déjà à ce stade).

[Ils doivent être rendus disponibles pour d\'autres plugins en tant que ressource,
depuis une requête ajax (dans une popup ou pas),
comme bouton ouvrant le plugin dans une popup
au sein d\'un article en rédigeant le connecteur,
en tant que bouton connexe à un article (comme les liens sociaux)
comme module placé sur la page
en pleine page /plugin/
ou appelée depuis une iframe /plug/:list]

Les plugins sont très simples à rédiger, à part qu\'il faut s\'accommoder de ses contraintes (deux variables libres et un socket multidonnées [1:nh]), mais en profitant de dispositifs puissants faciles à pomper sur d\'autres plugins.
Une classe objet \'Msql\' permet la gestion de bases de données utilisateur.
Au final un plugin comme le Chat (en ajax) s\'écrit en 40 lignes.

[[1:nb] les requêtes ajax régies par un protocole à 9 variables (cible, application, source, traitement, var 1, var 2, var 3, var 4, multivars). Le socket multivars reçoit des données d\'un formulaire ou aussi le résultat de AjaxMultithread, capable de faire voyager une énorme quantité de données.:q]

[Usages:h4]

Finalement on peut très bien concevoir la présence de Philum comme environnement (caractérisé par sa grande légèreté) pour ne publier qu\'un simple plugin, sur lequel le développeur passera tout son temps.
Il peut aussi bien servir de support pour écrire un mémoire que de base documentaire pour organiser les espèces animales entre elles (par exemple).

C\'est pourquoi le CMS est un Framework, parce que les fonctions système sont élémentaires, et que le principal se trouve dans la facilité à ajouter des fonctions et à les activer, dans un environnement où on peut se loguer, auquel on peut se référer, et où tout est balisé et rôdé.

Le progrès à faire sera de rendre cette rédaction de logiciels de plus en plus intuitive, tout en gardant l\'esprit assez clair pour savoir ce que cela signifie...

[Principales caractéristiques du Cms:h]

[Pour le visiteur:u]

[Html normalisé et ultra-rapide !
Lecteur de flux rss et de pages web
Accès aux données selon son propre choix de tri
Moteur de recherche puissant, précis, et chronologique
Restitution du site tel qu\'il apparaissait à une époque antérieure
Console Url faciles à comprendre et à réutiliser
Proposer des articles:list]

1 = commentateur
2 = propose articles à la publication
3 = publie articles et modifie les meta

[Pour le rédacteur de niveau 4:u]

Publication d\'articles et édition sur place
Aspiration d\'article depuis le web (et même à la chaîne)
Partage de fichiers, d\'articles et Chat entre serveurs
Articles organisés sur plusieurs plans : 
[un niveau de priorité (1 à 3)
une catégorie unique
une position dans un arbre d\'articles
un tag système ou n\'importe quelle autre classe de tags (les métas)
une référence à un autre article
un dossier virtuel (sous-menus infini)
une langue:list]

[Pour le concepteur de niveau 5:u]
[Développement Offline (sans toucher au noyau)
Gestion des Mods (paramètres qui génèrent une page, on peut revenir aux anciens ou les partager)
Gestion des modules et de leur fonctionnement conditionnel
Création du design depuis l\'interface (qui place les couleurs dans des variables, et permet de revenir / échanger des designs):list]

[Pour un Admin de niveau 6:u]
Gestion de membres
backups

SGBD additionnelle de type \"NoSql\" (très puissante) où on peut voir et intervenir sur absolument tout ce que \"raconte\" le logiciel (les parties impossibles à définir des fonctions vitales du logiciel, dite \"la partie molle\").

[Pour l\'administrateur de niveau 7:u]
pour lui chaque site est un hub sur sa base de données,
il peut attacher d\'autres couches sur cette base (noeuds)
ou tout refaire sur une nouvelle base,
attacher un nom de domaine à un hub, une couche ou à une base
(et ainsi donc) gérer des branches entre lesquelles des mises à jour peuvent s\'opérer.
(car) il peut développer en mode dev (sur les mêmes bases) ou en lab (sur d\'autres bases) et mettre en prod ses apports (bref faire sa propre distribution).

[Revenons à nos utilisateurs communs:h]

Philum est un outil complexe et poussé.
Pour concevoir un site créatif, il faut une plateforme ouverte et dont toutes les routines sont déclinables et améliorables. Pour cela, il faut à son tour que le code suive des règles faciles à comprendre et applicables instinctivement ensuite.

Le logiciel est écrit de telle sorte que toute sa rédaction est externalisée ; il n\'y a que des processus.
Il n\'y a pas de documentation, c\'est impossible à faire, il n\'y a que des bulles un peu partout.
L\'apparence de simplicité est liée à un sentiment de perfection et d\'exhaustivité, ce qui est difficile à obtenir. Il y a toujours un part confiée à l\'utilisateur, qu\'il doit apprendre lui-même.

[Les Mods:h4]

Le composant principal sont les modules. Ce sont des fonctionnalités du framework. Les modules peuvent appartenir à différentes couches logicielles, soit des actions incisives, soit des algorithmes poussés. 

Le module principal est le \"LOAD\", qui affiche les articles d\'après des paramètres globaux, affinables. Ensuite pour plus d\'affinité on peut juguler les variables de sortie, ou utiliser d\'autres templates, ou carrément un des nombreux autres modules presque similaires, parmi lesquels les modules \"articles\" qui permet de rédiger une commande Sql, et de choisir un mode de mise en forme.

Les blocs de modules sont les DIV de la page. Il y a un bloc réservé et obligatoire, le bloc système, qui contient des infos sur l\'architecture choisie, et les css utilisés (et dans quels contextes).

Ces ensembles de blocs de modules sont des \"Mods\" stockés dans des bases Msql (la base en dur de philum). Comme d\'habitude ils sont déclinables et échangeables.

[Les Css:h4]

Le css par défaut est automatiquement mis à jour en permanence. Il peut être supplanté à chaque mise à jour par une version avec les couleurs locales, ou devenir une fourche figée dans le temps (ce qui sera le plus souvent le cas).
Mais même là il repose encore sur le css global, moins souvent mit à jour, et qui assure le maintient technique minimal du logiciel.

L\'idée principale est qu\'on puisse faire évoluer ses css de façon continue car c\'est ça la meilleure manière de travailler et de s\'améliorer.
L\'édition des styles est grandement facilitée par un éditeur original, qui sépare les couleurs des définitions. Ainsi on peut utiliser des couleurs relatives. En une minute on peut entrer dans l\'éditeur, faire une modif qu\'on est le seul à voir (pas les visiteurs), et la publier aussitôt.

[Usage minimal:h]

Dans son état initial le logiciel permet de publier des articles en ligne, les organiser et les présenter.
Ils seront correctement affichés sur tous les écrans, ordis ou mobiles, ce qui correspond à 90% des usages.
Il suffit de l\'installer et de publier, c\'est fait pour ça.

A un premier niveau de curiosité on peut modifier son design et placer des modules qui paraissent judicieux.

Un utilisateur quotidien trouvera facilement des fonctionnalités même celles dont il n\'en a pas souvent besoin. Son travail consistera à ordonner l\'information et parfois créer des usages, comme le fait de consacrer chaque article à un produit.

Un développeur peut écrire des plugins qui peuvent être lancés dans l\'article, en pleine page, dans une popup, ou comme iframe. Les plugins peuvent s\'ancrer dans le Système.

[Le Desktop:h]

Quand on pousse un peu l\'usage, Philum peut se convertir en Desktop, un bureau avec des icônes d\'où on lance des activités qui apparaissent dans des popups. On peut lancer le site tel qu\'on l\'a conçu. Ou un autre. C\'est très pratique pour faire le design par exemple (affichage en temps réel), ou simplement pour proposer au visiteur de fouiller dans des répertoires virtuels, remplis des fichiers publiés par chacun des blogueurs du site.

Ces boutons qui apparaissent sur le bureau sont des objet multi-protocolaires qu\'on appelle des [Apps:b]. C\'est le chapitre le plus sophistiqué de Philum.
Aussi bien, à l\'origine ils servent à appeler un contenu dans une iframe, autant ils peuvent ouvrir des applications (les plugins), des activités du système (modules connecteurs etc...), des menus et sous-menus. 
Il y a un gestionnaire un peu primitif. Normalement on reçoit les apps système, on peut ne pas les afficher. On peut les juguler ou les décliner. En effet on peut vouloir ouvrir un article ou un dossier d\'articles (ils peuvent appartenir à un dossier virtuel).
On peut vouloir un fond d\'écran en dégradé aussi...

Les Apps peuvent appartenir à n\'importe lequel de ces 4 contextes :
[menu : s\'affiche dans le menu admin, dans l\'onglet des Apps
home : s\'affiche dans l\'onglet système (on peut y mettre des menus du site)
desk : s\'affiche comme icône de bureau
boot : est lancé au démarrage de la page:list]

En fait tout le système de menus déroulants en ajax est lié aux Apps, qui sont joignables par un connecteur.
Il y a plusieurs tables d\'Apps, les systèmes, les par défaut, et celles de l\'utilisateur. L\'avantage de cela est d\'y loger des commandes d\'activités, qui n\'ont plus qu\'à être appelées que par leur ID, au lieu d\'une somme (toujours grandissante) de paramètres à rédiger dans les connecteurs.

[Présentation des Connecteurs:h]

Ce langage utilisateur sert à écrire le html autant que des modules, en ne les désignant que par leur nom de balise. 
Il est relativement simple à lire :

[[[value§option:connector:on]:code]:q]

Le système des connecteurs assure l\'homogénéité de la mise en forme quelle que soit la source des données et un gain de poids de 30%.
Il permet aussi l\'écriture de templates ou encore de petites applis désignées par leur balise.

[[[hello:b:on]:code]:q]

[\'[hello:b]\' traité par le connecteur \'bold\':l]

[[[hello§param:my_plugin:on]:code]:q]

[Appel d\'un connecteur nommé \'my_plugin\' (soit créé en PHP, soit créé avec les dispositifs internes), auquel on envoie $p=hello et $o=param optionnel:l]

Voilà, et à partir d\'une idée aussi simple, tout est possible !

Visitez le [129§Tour] (qui date un peu désolé)

--
voyez [http://wiki.framasoft.info/PropositionNotice/Philum]
suivez [@philum_cms]
lisez [http://w41k.com]
embauchez [cms.philum@gmail.com]

[:last-update]');
$r[12]=array('[Présentation du projet:h]

L\'idée est que si on fait un travail on veut qu\'il serve le plus longtemps possible. L\'informatique permet d\'ajouter l\'intelligence des uns et des autres, au fil des années.
Et quand on trouve une nouvelle formulation, technique, ou logiciel, on préfère le rendre exploitable avec des commandes nous sont familières.
De ce fait le logiciel est destiné à assimiler les technologies sous l\'égide d\'une ontologie qui lui est propre.

[Présentation du framework:h]

Le développement d\'un site à haute fréquentation et avec une publication constante a conduit à construire des outils de traitement des données aussi variés que complexes.

D\'abord parce que désormais les sites sont améliorés de façon chronique et non plus une fois par période. (mise en prod instantanée)

Le logiciel et tous ses composants sont écris selon la forme :

[définition ([statique:l]) => constructeur ([algorithme:l]) => assemblage ([distribution dans des sockets:l]):q]
(pour dire \"sujet, verbe, complément\")

L\'avantage de l\'orienté composant (poussé à fond) est de pouvoir assembler n\'importe quel processus utilisant n\'importe quelle source de données. De pouvoir très vite agglomérer des belles fonctionnalités. De réduire considérablement la redondance. D\'assurer une maintenance intégrale sans aucune obsolescence. (C\'est plus dur et plus long mais ça rapporte plus sur le long terme)

Ainsi les fonctions sont classées entre celles du noyau (très simples et n\'en appelant aucune autre), les processus (qui organisent les données), et les dispositifs d\'assemblage des données.

Au chapitre de l\'assemblage il faut surtout noter le fait que les processus soient tous conforme à des [protocoles:b] connus par les assembleurs. Pour cela on a nommé différents types de tableaux multidimensionnels (aux doux noms de v, k, kv, kkv etc...)

Ainsi les templates sont traités par des fonctions satellites de celles qui ont généré les variables qui vont y être injectées [(tout ça pour pas avoir de balises vides):l].
En fait, plus simplement, on a un énorme dispositif nommé \"les connecteurs\" qui remplace le html. Le contenu des données est contrôlé balise par balise (et le superflu est supprimé), de façon à produire des pages 30% plus légères qu\'en html.
Surtout ces connecteurs font bien plus que ce que font de simples balises. 

Finalement l\'idée géniale du logiciel était de faire que les balises soient autant de fonctions qu\'on pouvait appeler, de façon à les assembler pour générer des [micro-applications:b].

Ce qui est difficile dans ce projet est de trouver la bonne échelle de ces fonctions et applications, car au final ça commence très bas, et ce qui apparaît à l\'utilisateur est déjà de l\'ordre de la troisième couche système du logiciel (puisque les assemblages de fonctions constitue autant de composants pour d\'autres assemblages).

C\'est pour cette raison que le framework est \"orienté composant\", ce qui parfois fait grimacer... En fait si on veut les assembler à la chaîne (de façon fractale), cela suppose une très grande rigidité dans la façon dont elles sont organisées, régies et rédigées.

L\'outil mis à disposition pour créer des fonctions (utilisées comme modules) en est à une phase extrêmement primitive de son évolution, et ça s\'appelle le \"codeline basic\" (parce que ça écrit du code en une ligne). C\'est une fonction satellite du \"codeline\" servant à rédiger les templates, qui est elle-même une fonction très allégée des Connecteurs.
Bon pour l\'instant ça sert juste pour des petits automatismes,comme par exemple ceux qui donnent des stats sur le logiciel, en page de download).

Sinon à part ça il reste à utiliser un parmi une [centaine de modules:b] et ses nombreux paramètres globaux, locaux et ponctuels.

En résumé on a :
[des modules qui utilisent des paramètres complexes (ce sont des traitement, qui réclament des données et des modes d\'assemblage)
des connecteurs, nombreux, peu paramétrables, possible à rédiger en clbasic
des templates, dans lesquels on place les variables, rédigés en codeline (qui sont des connecteurs orientés html)
des plugins, qui ont des tâches spécialisées, qui doivent être rédigées en php, en utilisant (ou pas) les ressources du framework.:list]

[Les connecteurs:h4]

Les connecteurs sont des commandes pour des activités, qui peuvent être complexes. C\'est finalement l\'accès complet à un logiciel (logé dans un plugin). Ils sont parfois plus complexes que les modules, peuvent servir de modules ou utiliser leurs ressources.

En fait les [plugins:b] peuvent être appelés en tant que module (hors de l\'article) ou connecteur (dans l\'article).

Voici quelques exemples de connecteurs disponibles par défaut :
[des liens opérationnels (youtube renvoie une popup, pdf un player... et une image : pas besoin de la rédiger
des galeries d\'images (:photo, :slider, :sliderj),
une :radio, 
une :petition, 
un livre d\'articles (:book), 
un autre article local, sur place ou en popup (:popart)
un article d\'un autre serveur philum (:rss_art)
un lecteur de bases de données utilisateurs d\'après un template (:msql_template), 
un menu ouvrable (:apps),
un template (:codeline)
etc etc...:list]

[Les plugins:h4]

L\'écosystème des plugins a été particulièrement soigné, parce que les plugins on peut en avoir besoin à de très nombreuses étapes (ou échelles) du logiciel.

Ce qui les caractérise est qu\'ils ne sont pas vitaux pour le logiciel, même s\'ils peuvent être requis par des options qui ne sont pas celles par défaut (déjà à ce stade).

[Ils doivent être rendus disponibles pour d\'autres plugins en tant que ressource,
depuis une requête ajax (dans une popup ou pas),
comme bouton ouvrant le plugin dans une popup
au sein d\'un article en rédigeant le connecteur,
en tant que bouton connexe à un article (comme les liens sociaux)
comme module placé sur la page
en pleine page /plugin/
ou appelée depuis une iframe /plug/:list]

Les plugins sont très simples à rédiger, à part qu\'il faut s\'accommoder de ses contraintes (deux variables libres et un socket multidonnées [1:nh]), mais en profitant de dispositifs puissants faciles à pomper sur d\'autres plugins.
Une classe objet \'Msql\' permet la gestion de bases de données utilisateur.
Au final un plugin comme le Chat (en ajax) s\'écrit en 40 lignes.

[[1:nb] les requêtes ajax régies par un protocole à 9 variables (cible, application, source, traitement, var 1, var 2, var 3, var 4, multivars). Le socket multivars reçoit des données d\'un formulaire ou aussi le résultat de AjaxMultithread, capable de faire voyager une énorme quantité de données.:q]

[Usages:h4]

Finalement on peut très bien concevoir la présence de Philum comme environnement (caractérisé par sa grande légèreté) pour ne publier qu\'un simple plugin, sur lequel le développeur passera tout son temps.
Il peut aussi bien servir de support pour écrire un mémoire que de base documentaire pour organiser les espèces animales entre elles (par exemple).

C\'est pourquoi le CMS est un Framework, parce que les fonctions système sont élémentaires, et que le principal se trouve dans la facilité à ajouter des fonctions et à les activer, dans un environnement où on peut se loguer, auquel on peut se référer, et où tout est balisé et rôdé.

Le progrès à faire sera de rendre cette rédaction de logiciels de plus en plus intuitive, tout en gardant l\'esprit assez clair pour savoir ce que cela signifie...

[Principales caractéristiques du Cms:h]

[Pour le visiteur:u]

[Html normalisé et ultra-rapide !
Lecteur de flux rss et de pages web
Accès aux données selon son propre choix de tri
Moteur de recherche puissant, précis, et chronologique
Restitution du site tel qu\'il apparaissait à une époque antérieure
Console Url faciles à comprendre et à réutiliser
Proposer des articles:list]

1 = commentateur
2 = propose articles à la publication
3 = publie articles et modifie les meta

[Pour le rédacteur de niveau 4:u]

Publication d\'articles et édition sur place
Aspiration d\'article depuis le web (et même à la chaîne)
Partage de fichiers, d\'articles et Chat entre serveurs
Articles organisés sur plusieurs plans : 
[un niveau de priorité (1 à 3)
une catégorie unique
une position dans un arbre d\'articles
un tag système ou n\'importe quelle autre classe de tags (les métas)
une référence à un autre article
un dossier virtuel (sous-menus infini)
une langue:list]

[Pour le concepteur de niveau 5:u]
[Développement Offline (sans toucher au noyau)
Gestion des Mods (paramètres qui génèrent une page, on peut revenir aux anciens ou les partager)
Gestion des modules et de leur fonctionnement conditionnel
Création du design depuis l\'interface (qui place les couleurs dans des variables, et permet de revenir / échanger des designs):list]

[Pour un Admin de niveau 6:u]
Gestion de membres
backups

SGBD additionnelle de type \"NoSql\" (très puissante) où on peut voir et intervenir sur absolument tout ce que \"raconte\" le logiciel (les parties impossibles à définir des fonctions vitales du logiciel, dite \"la partie molle\").

[Pour l\'administrateur de niveau 7:u]
pour lui chaque site est un hub sur sa base de données,
il peut attacher d\'autres couches sur cette base (noeuds)
ou tout refaire sur une nouvelle base,
attacher un nom de domaine à un hub, une couche ou à une base
(et ainsi donc) gérer des branches entre lesquelles des mises à jour peuvent s\'opérer.
(car) il peut développer en mode dev (sur les mêmes bases) ou en lab (sur d\'autres bases) et mettre en prod ses apports (bref faire sa propre distribution).

[Revenons à nos utilisateurs communs:h]

Philum est un outil complexe et poussé.
Pour concevoir un site créatif, il faut une plateforme ouverte et dont toutes les routines sont déclinables et améliorables. Pour cela, il faut à son tour que le code suive des règles faciles à comprendre et applicables instinctivement ensuite.

Le logiciel est écrit de telle sorte que toute sa rédaction est externalisée ; il n\'y a que des processus.
Il n\'y a pas de documentation, c\'est impossible à faire, il n\'y a que des bulles un peu partout.
L\'apparence de simplicité est liée à un sentiment de perfection et d\'exhaustivité, ce qui est difficile à obtenir. Il y a toujours un part confiée à l\'utilisateur, qu\'il doit apprendre lui-même.

[Les Mods:h4]

Le composant principal sont les modules. Ce sont des fonctionnalités du framework. Les modules peuvent appartenir à différentes couches logicielles, soit des actions incisives, soit des algorithmes poussés. 

Le module principal est le \"LOAD\", qui affiche les articles d\'après des paramètres globaux, affinables. Ensuite pour plus d\'affinité on peut juguler les variables de sortie, ou utiliser d\'autres templates, ou carrément un des nombreux autres modules presque similaires, parmi lesquels les modules \"articles\" qui permet de rédiger une commande Sql, et de choisir un mode de mise en forme.

Les blocs de modules sont les DIV de la page. Il y a un bloc réservé et obligatoire, le bloc système, qui contient des infos sur l\'architecture choisie, et les css utilisés (et dans quels contextes).

Ces ensembles de blocs de modules sont des \"Mods\" stockés dans des bases Msql (la base en dur de philum). Comme d\'habitude ils sont déclinables et échangeables.

[Les Css:h4]

Le css par défaut est automatiquement mis à jour en permanence. Il peut être supplanté à chaque mise à jour par une version avec les couleurs locales, ou devenir une fourche figée dans le temps (ce qui sera le plus souvent le cas).
Mais même là il repose encore sur le css global, moins souvent mis à jour, et qui assure le maintient technique minimal du logiciel.

L\'idée principale est qu\'on puisse faire évoluer ses css de façon continue car c\'est ça la meilleure manière de travailler et de s\'améliorer.
L\'édition des styles est grandement facilitée par un éditeur original, qui sépare les couleurs des définitions. Ainsi on peut utiliser des couleurs relatives. En une minute on peut entrer dans l\'éditeur, faire une modif qu\'on est le seul à voir (pas les visiteurs), et la publier aussitôt.

[Usage minimal:h]

Dans son état initial le logiciel permet de publier des articles en ligne, les organiser et les présenter.
Ils seront correctement affichés sur tous les écrans, ordis ou mobiles, ce qui correspond à 90% des usages.
Il suffit de l\'installer et de publier, c\'est fait pour ça.

A un premier niveau de curiosité on peut modifier son design et placer des modules qui paraissent judicieux.

Un utilisateur quotidien trouvera facilement des fonctionnalités même celles dont il n\'en a pas souvent besoin. Son travail consistera à ordonner l\'information et parfois créer des usages, comme le fait de consacrer chaque article à un produit.

Un développeur peut écrire des plugins qui peuvent être lancés dans l\'article, en pleine page, dans une popup, ou comme iframe. Les plugins peuvent s\'ancrer dans le Système.

[Le Desktop:h]

Quand on pousse un peu l\'usage, Philum peut se convertir en Desktop, un bureau avec des icônes d\'où on lance des activités qui apparaissent dans des popups. On peut lancer le site tel qu\'on l\'a conçu. Ou un autre. C\'est très pratique pour faire le design par exemple (affichage en temps réel), ou simplement pour proposer au visiteur de fouiller dans des répertoires virtuels, remplis des fichiers publiés par chacun des blogueurs du site.

Ces boutons qui apparaissent sur le bureau sont des objet multi-protocolaires qu\'on appelle des [Apps:b]. C\'est le chapitre le plus sophistiqué de Philum.
Aussi bien, à l\'origine ils servent à appeler un contenu dans une iframe, autant ils peuvent ouvrir des applications (les plugins), des activités du système (modules connecteurs etc...), des menus et sous-menus. 
Il y a un gestionnaire un peu primitif. Normalement on reçoit les apps système, on peut ne pas les afficher. On peut les juguler ou les décliner. En effet on peut vouloir ouvrir un article ou un dossier d\'articles (ils peuvent appartenir à un dossier virtuel).
On peut vouloir un fond d\'écran en dégradé aussi...

Les Apps peuvent appartenir à n\'importe lequel de ces 4 contextes :
[menu : s\'affiche dans le menu admin, dans l\'onglet des Apps
home : s\'affiche dans l\'onglet système (on peut y mettre des menus du site)
desk : s\'affiche comme icône de bureau
boot : est lancé au démarrage de la page:list]

En fait tout le système de menus déroulants en ajax est lié aux Apps, qui sont joignables par un connecteur.
Il y a plusieurs tables d\'Apps, les systèmes, les par défaut, et celles de l\'utilisateur. L\'avantage de cela est d\'y loger des commandes d\'activités, qui n\'ont plus qu\'à être appelées que par leur ID, au lieu d\'une somme (toujours grandissante) de paramètres à rédiger dans les connecteurs.

[Présentation des Connecteurs:h]

Ce langage utilisateur sert à écrire le html autant que des modules, en ne les désignant que par leur nom de balise. 
Il est relativement simple à lire :

[[[value§option:connector:on]:code]:q]

Le système des connecteurs assure l\'homogénéité de la mise en forme quelle que soit la source des données et un gain de poids de 30%.
Il permet aussi l\'écriture de templates ou encore de petites applis désignées par leur balise.

[[[hello:b:on]:code]:q]

[\'[hello:b]\' traité par le connecteur \'bold\':l]

[[[hello§param:my_plugin:on]:code]:q]

[Appel d\'un connecteur nommé \'my_plugin\' (soit créé en PHP, soit créé avec les dispositifs internes), auquel on envoie $p=hello et $o=param optionnel:l]

Voilà, et à partir d\'une idée aussi simple, tout est possible !

[--]Visitez le [129§Tour]
voyez [http://wiki.framasoft.info/PropositionNotice/Philum]
suivez [@philum_cms]
usez [http://philum.org]
lisez [http://philum.info]

[:last-update]');

?>